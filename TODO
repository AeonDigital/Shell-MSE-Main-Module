#
# Rodar testes:

. src/unittests.sh
. src/unittests.sh "mse_file_read"


## TODO
PROCURAR BOA ALTERNATIVA PARA VER MARKDOWNS NA TELA...
`glow` não é tão bom... ver se ao atualizar resolve os bugs encontrados.
criar um visualizador de markdown?!?

SEGUIR COM O MANUAL E O 'DEBUGADOR' DE SEÇÕES PARA PEGAR AS INFORMAÇÕES
DE CONFIGURAÇÃO PARA AS FUNÇÕES.


#
# Comandos usados que não são built-in do bash ?
[v] - dirname   [  2x ] (Core utils - Shell utilities)  Módulo de teste!
[v] - readlink  [  1x ] (Core utils - Shell utilities)  Módulo de teste!
[v] - sort      [  1x ] (Core utils - Text utilities)   Módulo de teste!

[.] - column    [  3x ] (bsdmainutils)
      mse_font_show_colors
      mse_font_show_attributes
      mse_font_show_characters
[v] - expr      [  2x ] (Core utils - Shell utilities)
      mse_interface_show_prompt
      mse_font_show_characters
[v] - find      [  5x ] (Find utils)                    Requisitos básicos
      modules.sh
      mse.sh
      unittests.sh
[v] - iconv     [  5x ] (libc-bin)
      mse_str_remove_glyphs
      mse_font_show_characters
      mse_file_convert_toUTF8
[v] - printf    [ 32x ] (Core utils - Shell utilities)
      mse_file_convert_toUTF8
      mse_str_convert_octal_toHex
      mse_str_convert_octal_toDecimal
      mse_str_convert_octal_toChar
      mse_str_convert_hex_toOctal
      mse_str_convert_hex_toDecimal
      mse_str_convert_hex_toChar
      mse_str_convert_decimal_toOctal
      mse_str_convert_decimal_toHex
      mse_str_convert_decimal_toChar
      mse_str_convert_char_toOctal
      mse_str_convert_char_toHex
      mse_str_convert_char_toDecimal
      mse_font_show_characters
      mse_font_create_style

[v] - sed       [ 11x ] (sed)
      mse_font_show_colors
      mse_font_show_characters

[v] - xxd       [  3x ] (xxd)
      mse_font_show_characters




## SEGUIR DAQUI->

# 4. VER A FUNÇÃO QUE ESTÁ NA RAIZ EM 'MODULE.SH' PARA ELA 'SAIR DE LÁ'!




#
# Ordena as chaves de um array associativo alfabeticamente
IFS=$'\n'
unset mseTmpPromptSortedKeys
declare -a mseTmpPromptSortedKeys=($(sort <<< "${!mseTmpPromptAssocValues[*]}"))
IFS=$' \t\n'



#
# Converte uma string com aspas simples ou duplas para array
Str="This string has \"a substring\" ' and now? '"
IFS=$'\n' mseTmpArray=( $(xargs -n1 <<<"$Str") )
printf '<%s>\n' "${arr[@]}"
<This>
<string>
<has>
<a substring>
< and now? >



#
# Split uma string em linhas
local mseLine=0
local mseLineRaw=""
local mseSectionContent=$(cat file)

IFS=$'\n'
while read -r mseLineRaw || [ -n "${mseLineRaw}" ]; do
  ((mseLine++))
  echo "${mseLine} - ${mseLineRaw}"
done <<< "${mseSectionContent}"
IFS=$' \t\n'

## Versão mais simples:
IFS=$'\n'
declare -a testResult=($(echo -e "${mseSectionContent[@]}"))
IFS=$' \t\n'



#
# Printar um determinado número de caracteres
char="#"
printf "${char}%.0s" {1..10}
# fazer isso x vezes
length=10
msePadStr=$(eval printf "${char}%.0s" {1..${length}})


Fazer uma função que substitua as entidades HTML pelos respectivos caracteres.
Ver se o 'iconv' já não faz isso.




[[:alnum:]]   Alphanumeric characters
[[:alpha:]]   Alphabetic characters
[[:blank:]]   Space and tab
[[:cntrl:]]   Control characters
[[:digit:]]   Digits
[[:graph:]]   Visible characters (anything except spaces and control characters)
[[:lower:]]   Lowercase letters
[[:print:]]   Visible characters and spaces (anything except control characters)
[[:punct:]]   Punctuation (and symbols).
[[:space:]]   All whitespace characters, including line breaks
[[:upper:]]   Uppercase letters
[[:xdigit:]]  Hexadecimal digits


1. Criando retornos [type]+

  mseReturn="bla bla bla\n"
  mseReturn+="Primeira linha de retorno"
  mseReturn+="\nSegunda linha de retorno"

2. Processa os caracteres especiais da string
  rawResult=$(printf "${mseReturn}")

3. Pega apenas o retorno esperado
  echo "${rawResult%%[![:graph:]]*}"
  echo "${rawResult%%$'\n'FUNCTION MESSAGE:$'\n'*}"

4. Pega apenas a mensagem de retorno
  echo "${rawResult#*[![:graph:]]}"
  echo "${rawResult#*$'\n'FUNCTION MESSAGE:$'\n'}"




# TRIM
# with 'sed'
# local mseReturn=$(echo "${1}" | sed -z -E -e 's/^[ \t\r\n]+//' | sed -z -E -e 's/[ \t\r\n]+$//')


# PAD
# with 'printf'
# printf "%-${msePadLeft}s"  # for empty spaces
# printf "${msePadChar}%.0s" $(eval "echo {1.."$((${msePadLeft}))


# ARGS TO ARRAY
# mseTargetArray=("$(xargs -n1 <<< "arg1 arg2 arg3 'and 4'")"")