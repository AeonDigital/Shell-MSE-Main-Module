#
# Rodar testes:

. src/unittests.sh
. src/unittests.sh "mse_file_read"


## TODO
PROCURAR BOA ALTERNATIVA PARA VER MARKDOWNS NA TELA...
`glow` não é tão bom... ver se ao atualizar resolve os bugs encontrados.
criar um visualizador de markdown?!?

SEGUIR COM O MANUAL E O 'DEBUGADOR' DE SEÇÕES PARA PEGAR AS INFORMAÇÕES
DE CONFIGURAÇÃO PARA AS FUNÇÕES.


#
# Comandos usados que não são built-in do bash ?
- printf  mse_array_print (printf "%s\n" "array")
- xargs
- find
- sed
- iconv



#
# Ordena as chaves de um array associativo alfabeticamente
IFS=$'\n'
unset mseTmpPromptSortedKeys
declare -a mseTmpPromptSortedKeys=($(sort <<< "${!mseTmpPromptAssocValues[*]}"))
IFS=$' \t\n'



#
# Converte uma string com aspas simples ou duplas para array
Str="This string has \"a substring\" ' and now? '"
IFS=$'\n' mseTmpArray=( $(xargs -n1 <<<"$Str") )
printf '<%s>\n' "${arr[@]}"
<This>
<string>
<has>
<a substring>
< and now? >



#
# Split uma string em linhas
local mseLine=0
local mseLineRaw=""
local mseSectionContent=$(cat file)

IFS=$'\n'
while read -r mseLineRaw || [ -n "${mseLineRaw}" ]; do
  ((mseLine++))
  echo "${mseLine} - ${mseLineRaw}"
done <<< "${mseSectionContent}"
IFS=$' \t\n'

## Versão mais simples:
IFS=$'\n'
declare -a testResult=($(echo -e "${mseSectionContent[@]}"))
IFS=$' \t\n'



#
# Printar um determinado número de caracteres
char="#"
printf "${char}%.0s" {1..10}
# fazer isso x vezes
length=10
msePadStr=$(eval printf "${char}%.0s" {1..${length}})


Fazer uma função que substitua as entidades HTML pelos respectivos caracteres.
Ver se o 'iconv' já não faz isso.




[[:alnum:]]   Alphanumeric characters
[[:alpha:]]   Alphabetic characters
[[:blank:]]   Space and tab
[[:cntrl:]]   Control characters
[[:digit:]]   Digits
[[:graph:]]   Visible characters (anything except spaces and control characters)
[[:lower:]]   Lowercase letters
[[:print:]]   Visible characters and spaces (anything except control characters)
[[:punct:]]   Punctuation (and symbols).
[[:space:]]   All whitespace characters, including line breaks
[[:upper:]]   Uppercase letters
[[:xdigit:]]  Hexadecimal digits


1. Criando retornos [type]+

  mseReturn="bla bla bla\n"
  mseReturn+="Primeira linha de retorno"
  mseReturn+="\nSegunda linha de retorno"

2. Processa os caracteres especiais da string
  rawResult=$(printf "${mseReturn}")

3. Pega apenas o retorno esperado
  echo "${rawResult%%[![:graph:]]*}"
  echo "${rawResult%%$'\n'FUNCTION MESSAGE:$'\n'*}"

4. Pega apenas a mensagem de retorno
  echo "${rawResult#*[![:graph:]]}"
  echo "${rawResult#*$'\n'FUNCTION MESSAGE:$'\n'}"
