# Load
chmod +x src/module.sh
. src/module.sh


# Run tests
./src/module.sh test
./src/module.sh test "mse_file_read"



## TODO
SEGUIR COM O MANUAL E O 'DEBUGADOR' DE SEÇÕES PARA PEGAR AS INFORMAÇÕES
DE CONFIGURAÇÃO PARA AS FUNÇÕES.


PROCURAR BOA ALTERNATIVA PARA VER MARKDOWNS NA TELA...
`glow` não é tão bom... ver se ao atualizar resolve os bugs encontrados.
criar um visualizador de markdown?!?








#
# Ordena as chaves de um array associativo alfabeticamente
IFS=$'\n'
unset mseTmpPromptSortedKeys
declare -a mseTmpPromptSortedKeys=($(sort <<< "${!mseTmpPromptAssocValues[*]}"))
IFS=$' \t\n'



#
# Converte uma string com aspas simples ou duplas para array
Str="This string has \"a substring\" ' and now? '"
IFS=$'\n' mseTmpArray=( $(xargs -n1 <<<"$Str") )
printf '<%s>\n' "${arr[@]}"
<This>
<string>
<has>
<a substring>
< and now? >



#
# Split uma string em linhas
local mseLine=0
local mseLineRaw=""
local mseSectionContent=$(cat file)

IFS=$'\n'
while read -r mseLineRaw || [ -n "${mseLineRaw}" ]; do
  ((mseLine++))
  echo "${mseLine} - ${mseLineRaw}"
done <<< "${mseSectionContent}"
IFS=$' \t\n'

## Versão mais simples:
IFS=$'\n'
declare -a testResult=($(echo -e "${mseSectionContent[@]}"))
IFS=$' \t\n'



#
# Printar um determinado número de caracteres
char="#"
printf "${char}%.0s" {1..10}
# fazer isso x vezes
length=10
msePadStr=$(eval printf "${char}%.0s" {1..${length}})


Fazer uma função que substitua as entidades HTML pelos respectivos caracteres.
Ver se o 'iconv' já não faz isso.




[[:alnum:]]   Alphanumeric characters
[[:alpha:]]   Alphabetic characters
[[:blank:]]   Space and tab
[[:cntrl:]]   Control characters
[[:digit:]]   Digits
[[:graph:]]   Visible characters (anything except spaces and control characters)
[[:lower:]]   Lowercase letters
[[:print:]]   Visible characters and spaces (anything except control characters)
[[:punct:]]   Punctuation (and symbols).
[[:space:]]   All whitespace characters, including line breaks
[[:upper:]]   Uppercase letters
[[:xdigit:]]  Hexadecimal digits


1. Criando retornos [type]+

  mseReturn="bla bla bla\n"
  mseReturn+="Primeira linha de retorno"
  mseReturn+="\nSegunda linha de retorno"

2. Processa os caracteres especiais da string
  rawResult=$(printf "${mseReturn}")

3. Pega apenas o retorno esperado
  echo "${rawResult%%[![:graph:]]*}"
  echo "${rawResult%%$'\n'FUNCTION MESSAGE:$'\n'*}"

4. Pega apenas a mensagem de retorno
  echo "${rawResult#*[![:graph:]]}"
  echo "${rawResult#*$'\n'FUNCTION MESSAGE:$'\n'}"




# TRIM
# with 'sed'
# local mseReturn=$(echo "${1}" | sed -z -E -e 's/^[ \t\r\n]+//' | sed -z -E -e 's/[ \t\r\n]+$//')


# PAD
# with 'printf'
# printf "%-${msePadLeft}s"  # for empty spaces
# printf "${msePadChar}%.0s" $(eval "echo {1.."$((${msePadLeft}))


# ARGS TO ARRAY
# mseTargetArray=("$(xargs -n1 <<< "arg1 arg2 arg3 'and 4'")"")